#!/usr/bin/python

import optparse
import os
import os.path
import sys
import yaml


class Configuration(object):

  def __init__(self):
    self.package = None


class FileSystem(object):

  def __init__(self, root):
    self.root = root

  def open_file(self, name):
    full_name = os.path.join(self.root, name)
    dirname = os.path.dirname(full_name)
    if not os.path.exists(dirname):
      os.makedirs(dirname)
    out = open(full_name, "wt")
    return CodeStream(out)


# A utility for printing source code.
class CodeStream(object):

  def __init__(self, out):
    self.out = out
    self.schedule_newline = False
    self.indent_level = 0

  def add(self, *strs):
    self.flush_newline()
    for s in strs:
      self.out.write(str(s))
    return self

  def newline(self):
    self.schedule_newline = True
    return self

  def flush_newline(self):
    if not self.schedule_newline:
      return
    self.schedule_newline = False
    self.out.write("\n" + ("  " * self.indent_level))

  def indent(self):
    self.indent_level += 1
    return self

  def deindent(self):
    self.indent_level -= 1
    return self

  def flush(self):
    self.flush_newline()
    self.out.close()


# Abstract supertype for the different declaration types.
class Declaration(object):

  def configure(self, config):
    pass

  def declare(self, namespace):
    pass

  def attach(self, namespace):
    pass

  def emit(self, fs, config):
    pass


class Settings(Declaration):

  def __init__(self, data):
    self.data = data["settings"]

  def configure(self, config):
    if "package" in self.data:
      config.package = self.data["package"]


# A service declaration
class Service(Declaration):

  def __init__(self, data):
    self.data = data
    self.commands = []

  def name(self):
    return self.data["service"]

  def declare(self, namespace):
    namespace[self.name()] = self

  def attach_command(self, command):
    self.commands.append(command)

  def emit(self, fs, config):
    # Create the file that will hold this service.
    path = self.name() + ".java"
    if not config.package is None:
      path = config.package.replace(".", "/") + "/" + path
    print "Generating", path
    out = fs.open_file(path)
    # Write the source code.
    out.add("// This file is auto generated by planktonc.").newline()
    if not config.package is None:
      out.add("package ", config.package, ";").newline()
    out.add("public class ", self.name(), " {").indent().newline()
    index = 0
    for command in self.commands:
      out.add("public static final int ", command.upper_name(), " = ", index, ";")
      out.newline()
      index += 1
    # Server interface
    out.add("public static interface IServer {").indent().newline()
    for command in self.commands:
      out.add("public Object ", command.name(), "();").newline()
    out.deindent().add("}").newline()    
    # Client bridge
    out.add("public static class Client {").indent().newline()
    out.deindent().add("}").newline()
    out.deindent().add("}");
    out.newline().flush()


# A command declaration.
class Command(Declaration):

  def __init__(self, data):
    self.data = data

  def target(self):
    return self.data["target"]

  def name(self):
    return self.data["command"]

  def upper_name(self):
    return self.name().upper()

  def attach(self, namespace):
    namespace[self.target()].attach_command(self)

  def emit_command(self, out):
    out.add("public void ", self.name(), "() {").newline()
    out.add("}").newline()


# A type declaration.
class Type(Declaration):

  def __init__(self, data):
    self.data = data


# Mapping from tagnames to the ast classes that implement those clauses.
_TAGS = {
  "service": Service,
  "command": Command,
  "type": Type,
  "settings": Settings,
}


def parse_files(names):
  decls = []
  for name in names:
    for decl in yaml.load(open(name, "rt")):
      tags = []
      for prop in decl.keys():
        tag = _TAGS.get(prop)
        if not tag is None:
          tags.append(tag)
      if len(tags) != 1:
        raise AssertionError("Invalid clause " + str(decl))
      decls.append(tags[0](decl))
  return decls


def build_parser():
  parser = optparse.OptionParser()
  parser.add_option("--out")
  return parser


def main():
  parser = build_parser()
  (flags, args) = parser.parse_args()
  decls = parse_files(args)
  namespace = {}
  config = Configuration()
  # Allow declarations to influence the config.
  for decl in decls:
    decl.configure(config)
  # Install any toplevel declarations in the namespace.
  for decl in decls:
    decl.declare(namespace)
  # Attach subdeclarations to their host declarations.
  for decl in decls:
    decl.attach(namespace)
  # Print the declarations.
  fs = FileSystem(flags.out)
  for decl in decls:
    decl.emit(fs, config)

if __name__ == "__main__":
  main()
