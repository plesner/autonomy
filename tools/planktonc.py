#!/usr/bin/python

import optparse
import os
import os.path
import sys
import yaml


class Configuration(object):

  def __init__(self):
    self.package = None


class FileSystem(object):

  def __init__(self, root):
    self.root = root

  def open_file(self, name):
    full_name = os.path.join(self.root, name)
    dirname = os.path.dirname(full_name)
    if not os.path.exists(dirname):
      os.makedirs(dirname)
    out = open(full_name, "wt")
    return CodeStream(out)

  def open_in_namespace(self, config, path):
    if not config.package is None:
      path = config.package.replace(".", "/") + "/" + path
    print "Generating", path
    return self.open_file(path)


# A utility for printing source code.
class CodeStream(object):

  def __init__(self, out):
    self.out = out
    self.schedule_newline = False
    self.indent_level = 0

  def add(self, *strs):
    self.flush_newline()
    for s in strs:
      self.out.write(str(s))
    return self

  def newline(self):
    self.schedule_newline = True
    return self

  def flush_newline(self):
    if not self.schedule_newline:
      return
    self.schedule_newline = False
    self.out.write("\n" + ("  " * self.indent_level))

  def indent(self, size=1):
    self.indent_level += size
    return self

  def deindent(self, size=1):
    self.indent_level -= size
    return self

  def flush(self):
    self.flush_newline()
    self.out.close()

  def comment(self, marker, text):
    for line in text.split("\n"):
      self.add(marker, " ", line).newline()
    return self


# Abstract supertype for the different declaration types.
class Declaration(object):

  def configure(self, config):
    pass

  def declare(self, namespace):
    pass

  def attach(self, namespace):
    pass

  def emit(self, fs, config):
    pass


class Settings(Declaration):

  def __init__(self, data):
    self.data = data["settings"]

  def configure(self, config):
    if "package" in self.data:
      config.package = self.data["package"]


# A service declaration
class Service(Declaration):

  def __init__(self, data):
    self.data = data
    self.commands = []

  def name(self):
    return self.data["service"]

  def declare(self, namespace):
    namespace[self.name()] = self

  def attach_command(self, command):
    self.commands.append(command)

  def emit(self, fs, config):
    # Create the file that will hold this service.
    path = self.name() + ".java"
    out = fs.open_in_namespace(config, path)
    # Write the source code.
    out.add("// This file is auto generated by planktonc.").newline()
    if not config.package is None:
      out.add("package ", config.package, ";").newline()
    out.add("public class ", self.name(), " {").indent().newline()
    index = 0
    for command in self.commands:
      out.add("public static final int ", command.upper_name(), " = ", index, ";")
      out.newline()
      index += 1
    # Server interface
    out.add("public static interface IServer {").indent().newline()
    for command in self.commands:
      out.add("public Object ", command.name(), "();").newline()
    out.deindent().add("}").newline()    
    # Client bridge
    out.add("public static class Client {").indent().newline()
    out.deindent().add("}").newline()
    out.deindent().add("}");
    out.newline().flush()


# A command declaration.
class Command(Declaration):

  def __init__(self, data):
    self.data = data

  def target(self):
    return self.data["target"]

  def name(self):
    return self.data["command"]

  def upper_name(self):
    return self.name().upper()

  def attach(self, namespace):
    namespace[self.target()].attach_command(self)

  def emit_command(self, out):
    out.add("public void ", self.name(), "() {").newline()
    out.add("}").newline()


_BASIC_TYPES = {
  "i32": "int",
  "string": "java.lang.String"
}
def pton_to_java_type(name):
  return _BASIC_TYPES.get(name, "P" + name)


def pair_to_decl((name, type)):
  return pton_to_java_type(type) + " " + name

_CAST_TYPES = {
  "i32": "java.lang.Integer",
  "string": "java.lang.String"
}
def construct(type, args):
  if type in _CAST_TYPES:
    return "(" + _CAST_TYPES[type] + ") " + args
  else:
    return pton_to_java_type(type) + ".parse(" + args + ")"

def to_upper_camel(name):
  return name[0].upper() + name[1:].lower()

def to_lines(data):
  if type(data) == dict:
    return "{\n" + ",\n".join(["  %s: %s" % (str(k), str(v)) for (k, v) in data.items()]) + "\n}"
  else:
    return str(data)

# A type declaration.
class Type(Declaration):

  def __init__(self, data):
    self.data = data

  def emit(self, fs, config):
    name = self.name()
    out = fs.open_in_namespace(config, name + ".java")
    # Write the source code.
    out.comment("//", "This file is auto generated by planktonc.")
    if not config.package is None:
      out.add("package ", config.package, ";").newline()
    out.add("import java.util.Map;").newline()
    out.comment("//", to_lines(self.data))
    out.add("public class ", self.name())
    implements = self.implements() + ['org.au.tonomy.shared.plankton.IPlanktonObject',
        'org.au.tonomy.shared.plankton.IPlanktonable<' + self.name() + ">"]
    out.add(" implements ", ", ".join(implements))
    out.add(" {").indent().newline()
    # Fields and accessors
    for (n, t) in self.fields():
      out.comment("//", "%s: %s" % (n, t))
      out.add("private final ", pair_to_decl((n, t)), ";").newline()
      out.add("public ", pton_to_java_type(t), " get", to_upper_camel(n), "() {").indent().newline()
      out.add("return this.", n, ";").newline();
      out.deindent().add("}").newline()
    # Builder
    out.add("public static class Builder {").indent().newline()
    # Fields and accessors
    for (n, t) in self.fields():
      out.add("private ", pair_to_decl((n, t)), ";").newline()
      out.add("public ", pton_to_java_type(t), " get", to_upper_camel(n), "() {").indent().newline()
      out.add("return this.", n, ";").newline();
      out.deindent().add("}").newline()
      out.add("public Builder set", to_upper_camel(n), "(",  pair_to_decl((n, t)), ") {").indent().newline()
      out.add("this.", n, " = ", n, ";").newline();
      out.add("return this;").newline();
      out.deindent().add("}").newline()
    out.add("public ", self.name(), " build() {").indent().newline()
    out.add("return new ", name, "(", ", ".join(["this.%s" % n for (n, t) in self.fields()]), ");").newline()
    out.deindent().add("}").newline()
    out.deindent().add("}").newline()
    out.add("public static Builder newBuilder() {").indent().newline()
    out.add("return new Builder();").newline()
    out.deindent().add("}").newline()
    # Constructor
    out.add("private ", name, "(", ", ".join(map(pair_to_decl, self.fields())), ") {").indent().newline()
    for (n, t) in self.fields():
      out.add("this.", n, " = ", n, ";").newline()
    out.deindent().add("}").newline()
    # Deserialize method
    out.add("public static ", name, " parse(Object data) {").indent().newline()
    out.add("Map<?, ?> map = (Map<?, ?>) data;").newline()
    for (n, t) in self.fields():
      out.add(pair_to_decl((n, t)), " = ", construct(t, "map.get(\"" + n + "\")"), ";").newline()  
    out.add("return new ", name, "(", ", ".join([n for (n, t) in self.fields()]), ");").newline()
    out.deindent().add("}").newline()
    # Serialize method
    out.add("@Override").newline()
    out.add("public Object toPlanktonData(org.au.tonomy.shared.plankton.IPlanktonFactory factory) {").indent().newline()
    out.add("return factory.newMap()").indent(2).newline()
    for (n, t) in self.fields():
      out.add(".set(\"", n, "\", this.", n, ")").newline()
    out.add(";").deindent(2).newline();
    out.deindent().add("}").newline()
    out.add("@Override").newline()
    out.add("public ", self.name(), " toPlankton() {").indent().newline()
    out.add("return this;").newline()
    out.deindent().add("}").newline()
    out.deindent().add("}").newline()
    out.flush()

  def name(self):
    return pton_to_java_type(self.data['type'])

  def fields(self):
    items = self.data["fields"].items()
    return sorted(items)

  def implements(self):
    return self.data.get("implements", [])



# Mapping from tagnames to the ast classes that implement those clauses.
_TAGS = {
  "service": Service,
  "command": Command,
  "type": Type,
  "settings": Settings,
}


def parse_files(names):
  decls = []
  for name in names:
    for decl in yaml.load(open(name, "rt")):
      tags = []
      for prop in decl.keys():
        tag = _TAGS.get(prop)
        if not tag is None:
          tags.append(tag)
      if len(tags) != 1:
        raise AssertionError("Invalid clause " + str(decl))
      decls.append(tags[0](decl))
  return decls


def build_parser():
  parser = optparse.OptionParser()
  parser.add_option("--out")
  return parser


def main():
  parser = build_parser()
  (flags, args) = parser.parse_args()
  decls = parse_files(args)
  namespace = {}
  config = Configuration()
  # Allow declarations to influence the config.
  for decl in decls:
    decl.configure(config)
  # Install any toplevel declarations in the namespace.
  for decl in decls:
    decl.declare(namespace)
  # Attach subdeclarations to their host declarations.
  for decl in decls:
    decl.attach(namespace)
  # Print the declarations.
  fs = FileSystem(flags.out)
  for decl in decls:
    decl.emit(fs, config)

if __name__ == "__main__":
  main()
