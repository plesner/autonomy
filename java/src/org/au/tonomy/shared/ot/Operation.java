package org.au.tonomy.shared.ot;

import org.au.tonomy.shared.util.Assert;
import org.au.tonomy.shared.util.Internal;

/**
 * A text operation.
 */
public abstract class Operation {

  /**
   * Identifies the different types of operations.
   */
  public enum Type {
    INSERT,
    DELETE,
    SKIP
  }

  /**
   * Returns the type of this operation.
   */
  public abstract Type getType();

  /**
   * Dispatch on this operation, which is the first operation in the
   * second in stream. We dispatch on the second operation first so that
   * the first operation is the one that will actually execute the
   * transformation, which makes the code more straightforward.
   */
  public abstract void xformDispatchSecond(OperationInputStream aIn,
      OperationOutputStream aOut, OperationInputStream bIn,
      OperationOutputStream bOut);

  /**
   * Transform this operation against an insertion.
   */
  public abstract void xformInsert(Insert that, OperationInputStream aIn,
      OperationOutputStream aOut, OperationInputStream bIn,
      OperationOutputStream bOut);

  /**
   * Transform this operation against a deletion.
   */
  public abstract void xformDelete(Delete that, OperationInputStream aIn,
      OperationOutputStream aOut, OperationInputStream bIn,
      OperationOutputStream bOut);

  /**
   * Transform this operation against a skip.
   */
  public abstract void xformSkip(Skip that, OperationInputStream aIn,
      OperationOutputStream aOut, OperationInputStream bIn,
      OperationOutputStream bOut);

  /**
   * Applies this operation to the out streams assuming that the
   * other sequence of operations is done.
   */
  public abstract void xformFlush(OperationOutputStream thisOut,
      OperationOutputStream thatOut);

  /**
   * Returns the inverse operation to this one, one that cancels the
   * effect if applied to the result of applying this operation.
   */
  public abstract Operation getInverse();

  /**
   * Applies this operation to an actual input string.
   */
  public abstract void apply(StringInput in, StringBuilder out);

  /**
   * Returns the length of the string generated by this operation.
   */
  public abstract int getOutputLength();

  /**
   * Returns the length of the input string consumed by applying this
   * operation.
   */
  public abstract int getInputLength();

  /**
   * Insert a piece of text at the current cursor.
   */
  public static class Insert extends Operation {

    private final String text;

    public Insert(String text) {
      Assert.that(!text.isEmpty());
      this.text = text;
    }

    @Override
    public Type getType() {
      return Type.INSERT;
    }

    @Override
    public void apply(StringInput in, StringBuilder out) {
      out.append(text);
    }

    @Override
    public Operation getInverse() {
      return new Delete(text);
    }

    @Override
    public int getOutputLength() {
      return text.length();
    }

    @Override
    public int getInputLength() {
      return 0;
    }

    @Override
    public void xformDispatchSecond(OperationInputStream aIn, OperationOutputStream aOut,
        OperationInputStream bIn, OperationOutputStream bOut) {
      aIn.getCurrent().xformInsert(this, aIn, aOut, bIn, bOut);
    }

    @Override
    public void xformInsert(Insert bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      Insert aOp = this;
      char aFirst = aOp.text.charAt(0);
      char bFirst = bOp.text.charAt(0);
      if (aFirst == bFirst) {
        // Both have the same effect so we don't have to do anything.
        aOut.skip(1);
        bOut.skip(1);
      } else if (aFirst < bFirst) {
        // A's character is lexically first so we first insert it,
        // then b's,
        aOut.insert(Character.toString(aFirst));
        aOut.skip(1);
        bOut.skip(1);
        bOut.insert(Character.toString(bFirst));
      } else {
        // B's character is lexically first so we first insert it,
        // then a's,
        bOut.insert(Character.toString(bFirst));
        bOut.skip(1);
        aOut.skip(1);
        aOut.insert(Character.toString(aFirst));
      }
      String aRest = text.substring(1);
      if (aRest.isEmpty()) {
        aIn.advance();
      } else {
        aIn.setCurrent(new Insert(aRest));
      }
      String bRest = bOp.text.substring(1);
      if (bRest.isEmpty()) {
        bIn.advance();
      } else {
        bIn.setCurrent(new Insert(bRest));
      }
    }

    /**
     * Returns the first offset where these two strings are different.
     */
    @Internal
    public static int getPrefixOffset(String first, String second) {
      int max = Math.min(first.length(), second.length());
      for (int i = 0; i < max; i++) {
        if (first.charAt(i) != second.charAt(i))
          return i;
      }
      return max;
    }

    @Override
    public void xformDelete(Delete bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      xformDeleteInsert(bOp, this, bIn, bOut, aIn, aOut);
    }

    @Override
    public void xformSkip(Skip bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      xformSkipInsert(bOp, this, bIn, bOut, aIn, aOut);
    }

    @Override
    public void xformFlush(OperationOutputStream thisOut, OperationOutputStream thatOut) {
      thatOut.skip(text.length());
      thisOut.insert(text);
    }

    @Override
    public int hashCode() {
      return text.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if (!(obj instanceof Insert)) {
        return false;
      } else {
        return this.text.equals(((Insert) obj).text);
      }
    }

    @Override
    public String toString() {
      return "(ins " + text + ")";
    }

  }

  /**
   * Delete the specified text, starting at the current cursor.
   */
  public static class Delete extends Operation {

    private final String text;

    public Delete(String text) {
      this.text = text;
    }

    @Override
    public Type getType() {
      return Type.DELETE;
    }

    @Override
    public void apply(StringInput in, StringBuilder out) {
      in.skip(text);
    }

    @Override
    public int getOutputLength() {
      return 0;
    }

    @Override
    public int getInputLength() {
      return text.length();
    }

    @Override
    public Operation getInverse() {
      return new Insert(text);
    }

    @Override
    public void xformDispatchSecond(OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      aIn.getCurrent().xformDelete(this, aIn, aOut, bIn, bOut);
    }

    @Override
    public void xformInsert(Insert bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      xformDeleteInsert(this, bOp, aIn, aOut, bIn, bOut);
    }

    @Override
    public void xformDelete(Delete bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      Delete aOp = this;
      char aFirst = aOp.text.charAt(0);
      char bFirst = bOp.text.charAt(0);
      if (aFirst == bFirst) {
        // Both have the same effect so we don't have to do anything.
      } else if (aFirst < bFirst) {
        // A's character is lexically first so we first delete it,
        // then b's,
        aOut.delete(Character.toString(aFirst));
        bOut.delete(Character.toString(bFirst));
      } else {
        // B's character is lexically first so we first delete it,
        // then a's,
        bOut.delete(Character.toString(bFirst));
        aOut.delete(Character.toString(aFirst));
      }
      String aRest = text.substring(1);
      if (aRest.isEmpty()) {
        aIn.advance();
      } else {
        aIn.setCurrent(new Delete(aRest));
      }
      String bRest = bOp.text.substring(1);
      if (bRest.isEmpty()) {
        bIn.advance();
      } else {
        bIn.setCurrent(new Delete(bRest));
      }
    }

    @Override
    public void xformSkip(Skip bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      xformSkipDelete(bOp, this, bIn, bOut, aIn, aOut);
    }

    @Override
    public void xformFlush(OperationOutputStream source, OperationOutputStream target) {
      target.delete(text);
    }

    @Override
    public int hashCode() {
      return text.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if (!(obj instanceof Delete)) {
        return false;
      } else {
        return this.text.equals(((Delete) obj).text);
      }
    }

    @Override
    public String toString() {
      return "(del " + text + ")";
    }

  }

  /**
   * Skip over the next n characters.
   */
  public static class Skip extends Operation {

    private final int count;

    public Skip(int count) {
      this.count = count;
    }

    @Override
    public Type getType() {
      return Type.SKIP;
    }

    @Override
    public void apply(StringInput in, StringBuilder out) {
      out.append(in.scan(count));
    }

    @Override
    public Operation getInverse() {
      return this;
    }

    @Override
    public int getOutputLength() {
      return count;
    }

    @Override
    public int getInputLength() {
      return count;
    }

    @Override
    public void xformDispatchSecond(OperationInputStream aIn, OperationOutputStream aOut,
        OperationInputStream bIn, OperationOutputStream bOut) {
      aIn.getCurrent().xformSkip(this, aIn, aOut, bIn, bOut);
    }

    @Override
    public void xformInsert(Insert bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      xformSkipInsert(this, bOp, aIn, aOut, bIn, bOut);
    }

    @Override
    public void xformDelete(Delete bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      xformSkipDelete(this, bOp, aIn, aOut, bIn, bOut);
    }

    @Override
    public void xformSkip(Skip bOp, OperationInputStream aIn,
        OperationOutputStream aOut, OperationInputStream bIn,
        OperationOutputStream bOut) {
      Skip aOp = this;
      if (aOp.count == bOp.count) {
        // If they have the same effect there's nothing to do.
        aOut.skip(aOp.count);
        bOut.skip(bOp.count);
        aIn.advance();
        bIn.advance();
      } else if (aOp.count < bOp.count) {
        // If a skips less than b then we skip that much ahead and then
        // compose the rest of b's skip with whatever comes after in a.
        aOut.skip(aOp.count);
        bOut.skip(aOp.count);
        aIn.advance();
        bIn.setCurrent(new Skip(bOp.count - aOp.count));
      } else {
        // And conversely when b skips less then a.
        aOut.skip(bOp.count);
        bOut.skip(bOp.count);
        bIn.advance();
        aIn.setCurrent(new Skip(aOp.count - bOp.count));
      }
    }

    @Override
    public void xformFlush(OperationOutputStream thisOut, OperationOutputStream thatOut) {
      thisOut.skip(count);
    }

    @Override
    public int hashCode() {
      return count;
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      } else if (!(obj instanceof Skip)) {
        return false;
      } else {
        return this.count == ((Skip) obj).count;
      }
    }

    @Override
    public String toString() {
      return "(skp " + count + ")";
    }

  }

  private static void xformSkipInsert(Skip skip, Insert insert, OperationInputStream skipIn,
      OperationOutputStream skipOut, OperationInputStream insertIn,
      OperationOutputStream insertOut) {
    // If text has been inserted in the part we're skipping we have
    // to skip the new text too.
    skipOut.skip(insert.text.length() + skip.count);
    skipIn.advance();
    insertOut.insert(insert.text);
    insertIn.advance();
  }

  private static void xformSkipDelete(Skip skip, Delete delete,
      OperationInputStream skipIn, OperationOutputStream skipOut,
      OperationInputStream deleteIn, OperationOutputStream deleteOut) {
    // If text has been delete in the part we're skipping we have
    // to not skip that part.
    skipOut.skip(skip.count - delete.text.length());
    skipIn.advance();
    deleteOut.delete(delete.text);
    deleteIn.advance();
  }

  private static void xformDeleteInsert(Delete delete, Insert insert,
      OperationInputStream deleteIn, OperationOutputStream deleteOut,
      OperationInputStream insertIn, OperationOutputStream insertOut) {
    // Just ignore the deletion and let it compose with the next
    // operation.
    insertOut.insert(insert.text);
    insertIn.advance();
    // The deletion should only be applied after the insertion so skip
    // the text.
    deleteOut.skip(insert.text.length());
  }

}
